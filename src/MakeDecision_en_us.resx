<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AlreadyStarted" xml:space="preserve">
    <value>{0:S} is already running</value>
  </data>
  <data name="AppExit" xml:space="preserve">
    <value>Exit application?</value>
  </data>
  <data name="HelpText" xml:space="preserve">
    <value>This application illustrates a math method that allows comparing some objects or events based on a set of criteria and choosing the most “correct” one. User is invited to independently select variants and criteria for their comparison, as well as specify significance of each criterion and each element. As a result, you’ll get the answer for the next question: “what way is the best”.

Each step is provided with explanations for this method. If necessary, all steps can be repeated again

***

Hotkeys:
Home – restarts the application (without losing the text);
PageDown – go to the next step;
Esc – exit the application;
F1 – call this help window;
Enter – enter a value and move to the next one;
Del – remove selected value from the list</value>
  </data>
  <data name="IncorrectValueError" xml:space="preserve">
    <value>Value must be an integer</value>
  </data>
  <data name="MakeDecisionForm_BExit" xml:space="preserve">
    <value>E&amp;xit</value>
  </data>
  <data name="MakeDecisionForm_BNext" xml:space="preserve">
    <value>&amp;Next</value>
  </data>
  <data name="MakeDecisionForm_BReset" xml:space="preserve">
    <value>&amp;Restart</value>
  </data>
  <data name="MakeDecisionForm_SkipUnnecessarySteps" xml:space="preserve">
    <value>Skip unnecessary steps</value>
  </data>
  <data name="NotEnoughCriteria" xml:space="preserve">
    <value>Not enough criteria to compare</value>
  </data>
  <data name="NotEnoughData" xml:space="preserve">
    <value>Not all cells are filled or one of them got zero value</value>
  </data>
  <data name="NotEnoughObjects" xml:space="preserve">
    <value>Not enough elements to compare</value>
  </data>
  <data name="ResultLabel" xml:space="preserve">
    <value>It follows from them that the element “{0: S}” is the best by given criteria</value>
  </data>
  <data name="Tab01_Label01" xml:space="preserve">
    <value>This application illustrates the use of nonlinear hierarchy analysis method for decision making.

Click “Next” to start the illustration</value>
  </data>
  <data name="Tab02_Label02" xml:space="preserve">
    <value>This method allows you to compare objects, phenomena or scenarios based on a set of criteria and select the most “correct” one, i. e. one for which the final coefficient will be the highest.

Therefore, firstly you must specify elements that you want to compare. To do this, simply enter their names into the list below</value>
  </data>
  <data name="Tab03_Label03" xml:space="preserve">
    <value>Now you need to select the criteria for comparing previously specified elements in the same way, as well as indicate their “price” – the degree of significance, priority.

It can be set “on a scale from 1 to 10” (to 100, to 1000), points, ratings – as you like. The main thing is that a HIGHER number determines a MORE SIGNIFICANT criterion</value>
  </data>
  <data name="Tab04_Label04" xml:space="preserve">
    <value>At this step, the comparison matrix is restored from obtained vector of priorities. To do this, a simple duplication of the original vector is performed until the matrix becomes square.

After this each column is divided by its own element, number of which is equal to number of column in the matrix. As a result, in matrix on the main diagonal, all elements become equal to 1</value>
  </data>
  <data name="Tab05_Label05" xml:space="preserve">
    <value>Similarly, elements evaluation vectors are set and processed according to each criterion. The only remark: HIGHER priority value should correspond to BETTER element, i. e. more suitable, compatible, cheaper, etc.</value>
  </data>
  <data name="Tab06_Label06" xml:space="preserve">
    <value>Now everything is ready to obtain final estimates of elements. This is done as follows:

• For all normalized matrices (both criteria and elements), harmonic vectors are compiled: each element of the vector is equal to product of elements of corresponding row of matrix raised to power inverse to number of elements in the row;
• Then matrices are multiplied by these vectors;
• Next, resulting price vectors of elements according to different criteria are merged into the matrix in the order in which these criteria were announced;
• Finally, this matrix is ​​multiplied by the price vector of the criteria.

Resulting vector will be the result of the method. The highest number in it will indicate the “best” element in given conditions</value>
  </data>
  <data name="Tab07_Label07" xml:space="preserve">
    <value>Results of hierarchy analysis:</value>
  </data>
  <data name="TooManyCriteria" xml:space="preserve">
    <value>Too many criteria to compare</value>
  </data>
  <data name="TooManyObjects" xml:space="preserve">
    <value>Too many elements to compare</value>
  </data>
</root>